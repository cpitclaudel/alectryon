<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Using the marker-placement mini-language</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="using-the-marker-placement-mini-language">
<h1 class="title">Using the marker-placement mini-language</h1>

<p>To compile:</p>
<pre class="literal-block">
$ alectryon references.rst
    # ReST ‚Üí HTML; produces ‚Äòreferences.html‚Äô
$ DOCUTILSCONFIG=references.docutils.conf alectryon \
    references.rst -o references.xe.tex --latex-dialect xelatex
    # ReST ‚Üí HTML; produces ‚Äòreferences.xe.tex‚Äô
</pre>
<div class="section" id="inserting-numbered-references">
<h1>Inserting numbered references</h1>
<p>Alectryon supports references to individual sentences and hypotheses within a code fragment.  The easiest way to reference a sentence is to use <tt class="docutils literal"><span class="pre">:mref:`search-term`</span></tt>.  Alectryon will search for that text and automatically add a label to the first matching sentence of the proof.  For example:</p>
<blockquote>
<pre class="alectryon-io highlight" id="setup"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk0" id="references-rst-fixpoint-plus-comm-0"><span class="kn">Fixpoint</span> <span class="nf">plus_comm</span> (<span class="nv">n</span> <span class="nv">m</span>: nat) {<span class="nv">struct</span> <span class="nv">n</span>} : n + m = m + n.<span class="alectryon-mref-marker">1</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + m = m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n + m = m + n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="references-rst-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk2" id="references-rst-destruct-n-0"><span class="nb">destruct</span> n <span class="nb">eqn</span>:Heq.<span class="alectryon-mref-marker">‚óâ</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal" id="references-rst-s-destruct-n-g-1-0"><div class="goal-hyps"><span id="references-rst-s-destruct-n-g-1-h-plus-comm-0"><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span><span class="alectryon-mref-marker">9</span></span><br><span id="references-rst-s-destruct-n-g-1-h-n-0"><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span><span class="alectryon-mref-marker">3</span></span><br><span id="references-rst-s-destruct-n-g-1-h-n-0-0"><var>Heq</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span><span class="alectryon-mref-marker">4</span></span><br></div><span class="goal-separator"><hr><span class="alectryon-mref-marker">2</span></span><div class="goal-conclusion" id="references-rst-s-destruct-n-ccl-0"><span class="mi">0</span> + m = m + <span class="mi">0</span><span class="alectryon-mref-marker">5</span></div></blockquote><div class="alectryon-extra-goals"><input checked="checked" class="alectryon-extra-goal-toggle" id="references-rst-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal" id="references-rst-s-destruct-n-g-s-n0-0"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span id="references-rst-s-destruct-n-g-s-n0-h-n-s-0"><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span><span class="alectryon-mref-marker">7</span></span><br></div><label class="goal-separator" for="references-rst-chk3"><hr><span class="alectryon-mref-marker">6</span></label><div class="goal-conclusion" id="references-rst-s-destruct-n-g-s-n0-ccl-0">S n0 + m = m + S n0<span class="alectryon-mref-marker">8</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk4" id="references-rst-io-setup-s-base-case-0">- <span class="c">(* Base case *)</span><span class="alectryon-mref-marker">10</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> + m = m + <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> &lt;- plus_n_O; <span class="bp">reflexivity</span>.</span></span></pre><p>The <code class="highlight coq"><span class="kn">Fixpoint</span></code> command (<a class="alectryon-mref reference internal" href="#references-rst-fixpoint-plus-comm-0">1</a>) indicates that we are beginning an inductive proof.</p>
</blockquote>
<p>Optionally, the label can be picked manually, using <tt class="docutils literal"><span class="pre">:mref:`label</span> &lt;target&gt;`</tt>:</p>
<blockquote>
The proof starts with a case analysis, indicated by ‚Äú<a class="alectryon-mref reference internal" href="#references-rst-destruct-n-0">‚óâ</a>‚Äù.</blockquote>
<p>Instead of whole sentences, is possible to refer to individual goals and hypotheses:</p>
<blockquote>
In the first case (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-0">2</a>), we see the variable <code class="highlight coq"><span class="n">n</span></code> in the context (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-n-0">3</a>), and we see that it is <code class="highlight coq"><span class="mi">0</span></code> (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-n-0-0">4</a>); notice how the conclusion of the first goal <a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-ccl-0">5</a> does not mention <code class="highlight coq"><span class="n">n</span></code> (it says <code class="highlight coq"><span class="mi">0</span></code> instead). In the second case <a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-s-n0-0">6</a>, we see that <code class="highlight coq"><span class="n">n</span></code> equals <code class="highlight coq"><span class="n">S</span> <span class="n">n0</span></code> (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-s-n0-h-n-s-0">7</a>) and the conclusion (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-s-n0-ccl-0">8</a>) mentions <code class="highlight coq"><span class="n">S</span> <span class="n">n0</span></code> instead of <code class="highlight coq"><span class="mi">0</span></code>.</blockquote>
<p>Note how the reference to a hypothesis of the second goal caused the whole hypothesis block to be unfolded (by default, hypotheses of secondary goals are folded).</p>
<p>As expected, referring multiple times to the same object creates a single marker, even using different references:</p>
<blockquote>
<ul class="simple">
<li><a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-plus-comm-0">9</a></li>
<li><a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-plus-comm-0">9</a></li>
<li><a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-plus-comm-0">9</a></li>
<li><a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-plus-comm-0">9</a></li>
</ul>
</blockquote>
<p>To allow forward- and back-references, counters are not reset from one block to the next:</p>
<blockquote>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk5" id="references-rst-induction-0">- <span class="c">(* Induction *)</span><span class="alectryon-mref-marker">11</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n0 + m = m + S n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (n0 + m) = m + S n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk7"><span class="nb">rewrite</span> (plus_comm n0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (m + n0) = m + S n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk8"><span class="nb">rewrite</span> plus_n_Sm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>plus_comm</var><span class="hyp-type"><b>: </b><span><span class="k">forall</span> <span class="nv">n</span> <span class="nv">m</span> : nat, n + m = m + n</span></span></span><br><span><var>n, m, n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m + S n0 = m + S n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><ul class="simple">
<li>Bullets (<tt class="docutils literal">-</tt>, <tt class="docutils literal">+</tt>, <tt class="docutils literal">*</tt>) delimit subproofs (<a class="alectryon-mref reference internal" href="#references-rst-io-setup-s-base-case-0">10</a>, <a class="alectryon-mref reference internal" href="#references-rst-induction-0">11</a>)</li>
<li>It all started at <a class="alectryon-mref reference internal" href="#references-rst-fixpoint-plus-comm-0">1</a></li>
</ul>
</blockquote>
<div class="section" id="defining-custom-counter-styles">
<h2>Defining custom counter styles</h2>
<p>Custom counter styles can be defined like using the <tt class="docutils literal">.. role::</tt> directive and the <tt class="docutils literal"><span class="pre">:counter-style:</span></tt> option:</p>
<p>Here is how it looks:</p>
<blockquote>
<p>The following commands print information about an identifier <a class="alectryon-mref aref reference internal" href="#references-rst-io-cp-s-about-0">Œ±</a>, print its definition <a class="alectryon-mref aref reference internal" href="#references-rst-io-cp-s-print-0">Œ≤</a>, and compute the type of a term <a class="alectryon-mref aref reference internal" href="#references-rst-io-cp-s-check-0">Œ≥</a> or its reduction <a class="alectryon-mref aref reference internal" href="#references-rst-io-cp-s-compute-0">Œ¥</a>.</p>
<pre class="alectryon-io highlight" id="cp"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk9" id="references-rst-io-cp-s-about-0"><span class="kn">About</span> Nat.add.<span class="alectryon-mref-marker">Œ±</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Nat.add : nat -&gt; nat -&gt; nat

Nat.add <span class="k">is</span> not universe polymorphic
<span class="kn">Arguments</span> Nat.add (n m)%nat_scope
Nat.add <span class="k">is</span> transparent
Expands to: Constant Coq.Init.Nat.add</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chka" id="references-rst-io-cp-s-print-0"><span class="kn">Print</span> Nat.add.<span class="alectryon-mref-marker">Œ≤</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Nat.add =
<span class="k">fix</span> add (n m : nat) {<span class="k">struct</span> n} : nat :=
  <span class="k">match</span> n <span class="k">with</span>
  | <span class="mi">0</span> =&gt; m
  | S p =&gt; S (add p m)
  <span class="k">end</span>
     : nat -&gt; nat -&gt; nat

<span class="kn">Arguments</span> Nat.add (n m)%nat_scope</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chkb" id="references-rst-io-cp-s-check-0"><span class="kn">Check</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">Œ≥</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">2</span> + <span class="mi">3</span>
     : nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chkc" id="references-rst-io-cp-s-compute-0"><span class="kn">Compute</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">Œ¥</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">5</span>
: nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-txt">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chkd" id="references-rst-io-cp-s-simpl-0"><span class="kn">Eval</span> <span class="nb">simpl</span> <span class="k">in</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">„ÅÑ</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">5</span>
: nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chke" id="references-rst-io-cp-s-cbn-0"><span class="kn">Eval</span> <span class="nb">cbn</span> <span class="k">in</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">„Çç</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">5</span>
: nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chkf" id="references-rst-io-cp-s-cbv-0"><span class="kn">Eval</span> <span class="nb">cbv</span> <span class="k">in</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">„ÅØ</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">5</span>
: nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk10" id="references-rst-io-cp-s-lazy-0"><span class="kn">Eval</span> <span class="nb">lazy</span> <span class="k">in</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">„Å´</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">5</span>
: nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk11" id="references-rst-io-cp-s-vm-compute-0"><span class="kn">Eval</span> <span class="nb">vm_compute</span> <span class="k">in</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">„Åª</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">5</span>
: nat</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk12" id="references-rst-io-cp-s-pattern-0"><span class="kn">Eval</span> <span class="nb">pattern</span> <span class="mi">2</span> <span class="k">in</span> Nat.add <span class="mi">2</span> <span class="mi">3</span>.<span class="alectryon-mref-marker">„Å∏</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= (<span class="k">fun</span> <span class="nv">n</span> : nat =&gt; n + S n) <span class="mi">2</span>
: nat</blockquote></div></div></small></span></pre><p>The second batch of commands perform reduction with a custom strategy: <a class="alectryon-mref jref reference internal" href="#references-rst-io-cp-s-simpl-0">„ÅÑ</a> <a class="alectryon-mref jref reference internal" href="#references-rst-io-cp-s-cbn-0">„Çç</a> <a class="alectryon-mref jref reference internal" href="#references-rst-io-cp-s-cbv-0">„ÅØ</a> <a class="alectryon-mref jref reference internal" href="#references-rst-io-cp-s-lazy-0">„Å´</a> <a class="alectryon-mref jref reference internal" href="#references-rst-io-cp-s-vm-compute-0">„Åª</a> <a class="alectryon-mref jref reference internal" href="#references-rst-io-cp-s-pattern-0">„Å∏</a>.</p>
</blockquote>
<p>Each inline reference is a link to the corresponding code fragment.</p>
</div>
</div>
<div class="section" id="setting-properties">
<h1>Setting properties</h1>
<p>Objects located using the marker-placement mini-language can be tagged with arbitrary properties by appending a <tt class="docutils literal"><span class="pre">[key]=val</span></tt> annotation to the placement expression.  For example:</p>
<blockquote>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk13"><span class="kn">Check</span> nat.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nat
     : <span class="kt">Set</span></blockquote></div></div></small></span></pre></blockquote>
<p>These properties can then be used within custom transforms.  Out of the box, Alectryon only recognizes the <tt class="docutils literal">[lang]</tt> annotation; if it is found, the corresponding code is highlighted using the Pygments lexer for that language.</p>
<blockquote>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Extraction Language Haskell</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="references-rst-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk14"><span class="kn">Extraction</span> Nat.add.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="nf">add</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Nat</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Nat</span>
<span class="nf">add</span><span class="w"> </span>n<span class="w"> </span>m<span class="w"> </span><span class="ow">=</span>
<span class="w">  </span><span class="kr">case</span><span class="w"> </span>n<span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">O</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span>m<span class="p">;</span>
<span class="w">   </span><span class="kt">S</span><span class="w"> </span>p<span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">S</span><span class="w"> </span><span class="p">(</span>add<span class="w"> </span>p<span class="w"> </span>m<span class="p">)}</span>

</blockquote></div></div></small></span></pre></blockquote>
</div>
<div class="section" id="inserting-textual-references">
<h1>Inserting textual references</h1>
<p>Instead of inserting a link to the relevant goal fragment, you can use the <tt class="docutils literal">:mquote:</tt> role to insert a copy of a goal fragment inline. This only works for an input sentence, the conclusion or name of a goal, and the type, body, or name of a hypothesis:</p>
<blockquote>
The proof above had two cases: <samp class="alectryon-inline highlight"><!-- Generator: Alectryon --><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span></samp> (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-1-h-n-0-0">4</a>) and <samp class="alectryon-inline highlight"><!-- Generator: Alectryon --><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span></span></samp> (<a class="alectryon-mref reference internal" href="#references-rst-s-destruct-n-g-s-n0-h-n-s-0">7</a>).
The second goal below is named <samp class="alectryon-inline highlight"><!-- Generator: Alectryon -->gg</samp>.
The last case of the proof below has two induction hypotheses: <samp class="alectryon-inline highlight"><!-- Generator: Alectryon -->List.In a l -&gt; List.In a l&#39;</samp> and <samp class="alectryon-inline highlight"><!-- Generator: Alectryon -->List.In a l&#39; -&gt; List.In a l&#39;&#39;</samp>. The two permutation hypotheses are <samp class="alectryon-inline highlight"><!-- Generator: Alectryon --><var>H</var></samp> and <samp class="alectryon-inline highlight"><!-- Generator: Alectryon --><var>H0</var></samp>.</blockquote>
<p>For conciseness, it is possible to define an alias of <tt class="docutils literal">:mquote:</tt> that uses a fixed prefix.  Notice how the second example overrides the <tt class="docutils literal">.g</tt> part of the prefix, too.</p>
<blockquote>
The proof above had two cases: <samp class="alectryon-inline highlight mq-s"><!-- Generator: Alectryon --><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span></samp> and <samp class="alectryon-inline highlight mq-s"><!-- Generator: Alectryon --><span><var>Heq</var><span class="hyp-type"><b>: </b><span>n = S n0</span></span></span></samp>.
The second goal below is named <samp class="alectryon-inline highlight mq-pr"><!-- Generator: Alectryon -->gg</samp>.
The last case of the proof below has two induction hypotheses: <samp class="alectryon-inline highlight mq-pr"><!-- Generator: Alectryon -->List.In a l -&gt; List.In a l&#39;</samp> and <samp class="alectryon-inline highlight mq-pr"><!-- Generator: Alectryon -->List.In a l&#39; -&gt; List.In a l&#39;&#39;</samp>.
The two permutation hypotheses are <samp class="alectryon-inline highlight mq-pr"><!-- Generator: Alectryon --><var>H</var></samp> and <samp class="alectryon-inline highlight mq-pr"><!-- Generator: Alectryon --><var>H0</var></samp>.</blockquote>
<p>Newlines in quoted objects are removed, and line breaks are allowed:</p>
<blockquote>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">P</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} :=
  { p_first: A;
    p_second: B }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk15"><span class="kn">Goal</span> <span class="k">forall</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">p</span>: @P A B),
  <span class="k">let</span> <span class="nv">a_first</span> := p.(p_first) <span class="k">in</span>
  <span class="k">let</span> <span class="nv">b_second</span> := p.(p_second) <span class="k">in</span>
  {| p_first := a_first;
     p_second := b_second |} = p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : P),
<span class="k">let</span> <span class="nv">a_first</span> := p_first p <span class="k">in</span>
<span class="k">let</span> <span class="nv">b_second</span> := p_second p <span class="k">in</span>
{| p_first := a_first; p_second := b_second |} = p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">p</span> : P),
<span class="k">let</span> <span class="nv">a_first</span> := p_first p <span class="k">in</span>
<span class="k">let</span> <span class="nv">b_second</span> := p_second p <span class="k">in</span>
{| p_first := a_first; p_second := b_second |} = p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The first sentence is <samp class="alectryon-inline highlight"><!-- Generator: Alectryon --><span class="kn">Record</span> <span class="nf">P</span> {<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>} :=
  { p_first: A;
    p_second: B }.</samp>.  <a class="footnote-reference" href="#f1" id="footnote-reference-1">[1]</a></p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>The second sentence is <samp class="alectryon-inline highlight"><!-- Generator: Alectryon --><span class="kn">Goal</span> <span class="k">forall</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">p</span>: @P A B),
  <span class="k">let</span> <span class="nv">a_first</span> := p.(p_first) <span class="k">in</span>
  <span class="k">let</span> <span class="nv">b_second</span> := p.(p_second) <span class="k">in</span>
  {| p_first := a_first;
     p_second := b_second |} = p.</samp>.  Later on we'll see a message: <samp class="alectryon-inline highlight"><!-- Generator: Alectryon -->Ignoring implicit <span class="kn">binder</span> declaration <span class="k">in</span> unexpected position.
[unexpected-implicit-declaration,syntax,default]</samp>.</td></tr>
</tbody>
</table>
</blockquote>
<p>To preserve newlines, use the <tt class="docutils literal">.. mquote::</tt> directive instead:</p>
<blockquote>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon --><span class="kn">Goal</span> <span class="k">forall</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">p</span>: @P A B),
  <span class="k">let</span> <span class="nv">a_first</span> := p.(p_first) <span class="k">in</span>
  <span class="k">let</span> <span class="nv">b_second</span> := p.(p_second) <span class="k">in</span>
  {| p_first := a_first;
     p_second := b_second |} = p.</pre><pre class="alectryon-block highlight"><!-- Generator: Alectryon -->Ignoring implicit <span class="kn">binder</span> declaration <span class="k">in</span> unexpected position.
[unexpected-implicit-declaration,syntax,default]</pre></blockquote>
<p>There, too, you may want to define aliases:</p>
<blockquote>
<pre class="alectryon-block highlight mq-pr"><!-- Generator: Alectryon --><span><var>H</var><span class="hyp-type"><b>: </b><span>Permutation l l&#39;</span></span></span></pre><pre class="alectryon-block highlight mq-pr"><!-- Generator: Alectryon --><span><var>H0</var><span class="hyp-type"><b>: </b><span>Permutation l&#39; l&#39;&#39;</span></span></span></pre></blockquote>
<p>Finally, you may chose a different Pygments lexer to highlight a quote.  For example, here is a piece of Scheme code produced by <tt class="docutils literal">Extraction</tt>:</p>
<blockquote>
<pre class="alectryon-block highlight"><!-- Generator: Alectryon --><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="nv">add</span><span class="w"> </span><span class="p">(</span><span class="nf">lambdas</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="nv">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="nv">n</span>
<span class="w">     </span><span class="p">((</span><span class="nf">O</span><span class="p">)</span><span class="w"> </span><span class="nv">m</span><span class="p">)</span>
<span class="w">     </span><span class="p">((</span><span class="nf">S</span><span class="w"> </span><span class="nv">p</span><span class="p">)</span><span class="w"> </span>`<span class="p">(</span><span class="nf">S</span><span class="w"> </span>,<span class="p">(</span><span class="k">@</span><span class="w"> </span><span class="nv">add</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="nv">m</span><span class="p">))))))</span>

</pre></blockquote>
</div>
<div class="section" id="customizing-proof-rendering-experimental">
<h1>Customizing proof rendering (<strong>experimental</strong>)</h1>
<p>References can also be used to customize the display of goals and hypotheses.  In the following, hypotheses whose name start with <tt class="docutils literal">l</tt> are omitted, and so are hypotheses named <tt class="docutils literal">a</tt> and <tt class="docutils literal">A</tt>.  After the call to <tt class="docutils literal">induction</tt> (<a class="alectryon-mref reference internal" href="#references-rst-io-pr-s-induction-1-0">12</a>) the output is further limited to just goals 2 and 4, by excluding all goals and re-including only 2 and 4.  In goal 4, hypotheses whose type is exactly <tt class="docutils literal">list A</tt> are shown, regardless of previous status, so <tt class="docutils literal">l</tt>, <tt class="docutils literal">l'</tt>, <tt class="docutils literal">l''</tt> are visible (<a class="alectryon-mref reference internal" href="#references-rst-io-pr-s-induction-1-g-4-h-l-0">13</a>).  Finally, the <tt class="docutils literal"><span class="pre">-.s(‚Ä¶).msg(‚Ä¶)</span></tt> annotation reduces output for the second line (<tt class="docutils literal">Check ‚Ä¶</tt>) to include only the warning that it produces (and not its regular output); and the <tt class="docutils literal"><span class="pre">-.s{Proof.}</span></tt> annotation completely hides the <tt class="docutils literal">Proof.</tt> line.</p>
<blockquote>
<pre class="alectryon-io highlight" id="pr"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="references-rst-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk17"><span class="kn">Check</span> <span class="k">let</span> <span class="nv">t</span> := nat <span class="k">in</span> <span class="k">forall</span> {<span class="nv">n</span>: t}, n &gt;= <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Ignoring implicit <span class="kn">binder</span> declaration <span class="k">in</span> unexpected position.
[unexpected-implicit-declaration,syntax,default]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="references-rst-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk18"><span class="kn">Theorem</span> <span class="nf">Permutation_In</span> {<span class="nv">A</span>} (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">a</span>: A) :
  Permutation l l&#39; -&gt; List.In a l -&gt; List.In a l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation l l&#39; -&gt; List.In a l -&gt; List.In a l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="references-rst-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk19" id="references-rst-io-pr-s-induction-1-0"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">intros</span> * Hin; [ | <span class="nb">refine</span> ?[gg] | .. ].<span class="alectryon-mref-marker">12</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>Permutation l l&#39;</span></span></span><br><span><var>IHPermutation</var><span class="hyp-type"><b>: </b><span>List.In a l -&gt; List.In a l&#39;</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>List.In a (x :: l)</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">gg</span></span><div class="goal-conclusion">List.In a (x :: l&#39;)</div></blockquote><div class="alectryon-extra-goals"><input checked="checked" class="alectryon-extra-goal-toggle" id="references-rst-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span id="references-rst-io-pr-s-induction-1-g-4-h-l-0"><var>l, l', l''</var><span class="hyp-type"><b>: </b><span>list A</span></span><span class="alectryon-mref-marker">13</span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Permutation l l&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Permutation l&#39; l&#39;&#39;</span></span></span><br><span><var>IHPermutation1</var><span class="hyp-type"><b>: </b><span>List.In a l -&gt; List.In a l&#39;</span></span></span><br><span><var>IHPermutation2</var><span class="hyp-type"><b>: </b><span>List.In a l&#39; -&gt; List.In a l&#39;&#39;</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>List.In a l</span></span></span><br></div><label class="goal-separator" for="references-rst-chk1a"><hr></label><div class="goal-conclusion">List.In a l&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-txt">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">simpl</span> <span class="k">in</span> *; <span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></blockquote>
</div>
<div class="section" id="asserting-properties-of-the-output">
<h1>Asserting properties of the output</h1>
<p>A constant concern when displaying proof states to readers is that what is displayed to the user may go stale.  Alectryon mitigates the issue by automatically collecting proof states, but simply recording the prover's output doesn't fully solve the issue.  That is because the output of a command may change in an unexpected way, without raising an error.  For example, we may have written, with an early version of Coq:</p>
<blockquote>
<pre class="alectryon-io highlight" id="plus"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk1b"><span class="kn">Print</span> plus.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Notation</span> <span class="nf">plus</span> := Nat.add</blockquote></div></div></small></span></pre></blockquote>
<p>To show the recursive definition of addition.   But as Coq's standard library got reorganized, the definition of <code class="highlight coq"><span class="n">plus</span></code> changed to being an alias for <code class="highlight coq"><span class="n">Nat</span><span class="o">.</span><span class="n">add</span></code>, making the output of <code class="highlight coq"><span class="kn">Print</span> <span class="n">plus</span></code> uninteresting.  In general, the recommended way to prevent this issue is by recording and versioning the prover's output using Alectryon caching facility (<tt class="docutils literal"><span class="pre">--cache-directory</span></tt>).  For small checks, however, Alectryon provides the <tt class="docutils literal">massert</tt> directive, which checks that all references in its body resolve to a part of Coq's output.  For example, the following checks that <code class="highlight coq"><span class="n">plus</span></code> is indeed an alias and <code class="highlight coq"><span class="n">Nat</span><span class="o">.</span><span class="n">add</span></code> a <code class="highlight coq"><span class="kn">Fixpoint</span></code>.</p>
<blockquote>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="references-rst-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="references-rst-chk1c"><span class="kn">Print</span> Nat.add.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Nat.add =
<span class="k">fix</span> add (n m : nat) {<span class="k">struct</span> n} : nat :=
  <span class="k">match</span> n <span class="k">with</span>
  | <span class="mi">0</span> =&gt; m
  | S p =&gt; S (add p m)
  <span class="k">end</span>
     : nat -&gt; nat -&gt; nat

<span class="kn">Arguments</span> Nat.add (n m)%nat_scope</blockquote></div></div></small></span></pre></blockquote>
</div>
</div>
</div></body>
</html>
